<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wanda Juan - Project</title><link href="/" rel="alternate"></link><link href="/feeds/project.atom.xml" rel="self"></link><id>/</id><updated>2019-12-23T00:00:00-05:00</updated><entry><title>Predictive Maintenance -- Survival Analysis</title><link href="/predictive-maintenance-survival-analysis.html" rel="alternate"></link><published>2019-12-23T00:00:00-05:00</published><updated>2019-12-23T00:00:00-05:00</updated><author><name>Wanda Juan</name></author><id>tag:None,2019-12-23:/predictive-maintenance-survival-analysis.html</id><summary type="html">&lt;p&gt;Hands on Survival Analysis using Lifeline&lt;/p&gt;</summary><content type="html">&lt;details&gt;
    &lt;summary&gt;
* View this markdown in [github](https://github.com/wanda15tw/survival-analysis), [HackMD](https://hackmd.io/@wG5x2COsRkOpxhsHnBO1_A/HJzZ880AS)

* [Code in notebook](https://github.com/wanda15tw/survival-analysis/blob/master/1223%20Survival%20Analysis%20-%20confidential%20removed.ipynb)


###### tags: `tech blog`, `tutorials`, `predictive maintenance`, `python`, `lifelines`
[complete notebook](https://github.com/wanda15tw/survival-analysis/blob/master/1223%20Survival%20Analysis%20-%20confidential%20removed.ipynb)

**Predictive maintenance** is to predict *which machinery at which condition needs preventative maintenance* so as to eliminate outages and the costs associated with it. Instead of predicting each individual part's failure, **Survival analysis** is a statistics approach to estimate failure rate. It is also called **reliability analysis** and **event history analysis**. Simply put, it intends to answer -- "How long until an event occurs?"
&lt;/summary&gt;

For example, 
* How long patients survive?
* How long mechanical parts last?

In this tutorial, we exemplify the second question with 28,529 censored parts which had no failure history, 1334 failed parts and their time to event (fail or exit the censorship). Input table is prepared as below with `event` and `time_to_event` columns.

![input_table](https://i.imgur.com/tUZJwqi.png)


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;df.event.value_counts()

# censor    28529
# fail       1334
# Name: event, dtype: int64
&lt;/pre&gt;&lt;/div&gt;


## Kaplan-Meier Estimation
At each **t + 1**, compute how many **at risk**, which is the last entrance substracted by parts failed at **t** and also those did not fail but monitored until **t** (i.e. # censored) 

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;KaplanMeierFitter&lt;/span&gt;

&lt;span class="n"&gt;durations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;time_to_event&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# workarounds for DOA&lt;/span&gt;
&lt;span class="n"&gt;event_observed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;event&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fail&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;km&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;KaplanMeierFitter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;km&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;durations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;KM&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


* Event Table:

`km.event_table`

![event_table](https://i.imgur.com/r9daMYo.png)




## Survival Function
* What fraction survive past t?
* e.g., 5-yr survival rates, median survival time
* Also called **Reliability Function**

![survival function](https://i.imgur.com/OBTq3Nc.png)

### Estimated by event table 
Survival function can be estimated by the following formula where $d_i$ stands for number of defects/observed and $n_i$ is number of parts entering period $i$ / **at risk**.
![km survival function](https://i.imgur.com/gu15mJ6.png)

`km.survival_function_`

![km.survival_function](https://i.imgur.com/SeKYnVm.png)

## Hazard Function
* Of the people who survive until t, what fraction die at t?
* Conditional density probability

$$
\lambda(t) = {f(y)\over S(t)}
$$

* The hazard function might be of more intrinsic interest than the
p.d.f. to a patient who had survived a certain time period and wanted to
know something about their prognosis.

## Popular Distributions
### Weibull


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; 

&lt;span class="n"&gt;wbf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;WeibullFitter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;durations&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:],&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:],&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;WeibullFitter&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;wbf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;summary&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/FZpn2YZ.png)

`wbf.plot_hazard()`
![weibull_hazard](https://i.imgur.com/Tu84f6d.png)


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plt.figure(figsize=(10, 24))
plt.subplot(4, 1, 1)
wbf.plot_survival_function()
plt.title(&amp;#39;Survival Curve&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Survival Probability&amp;#39;)

plt.subplot(4, 1, 2)
wbf.plot_cumulative_density()
plt.title(&amp;#39;Cumulative Failure Density&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Cum. Density Prob. (failure)&amp;#39;)


plt.subplot(4, 1, 3)
wbf.plot_hazard()
plt.title(&amp;#39;Hazard Function&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Hazard Function (pdf)&amp;#39;)

plt.subplot(4, 1, 4)
wbf.plot_cumulative_hazard()
plt.title(&amp;#39;Cumulative Hazard Function&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Cumulative Hazard Function&amp;#39;)

plt.show()
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/vMpKXpj.png)


### QQPlot

In fact, weibull distribution fits our data poortly, and we can observe that by looking at qqplot as below. None falls on the diagonal line. Instead, Log Normal seems to be a better fit.


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;lifelines.plotting&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;qq_plot&lt;/span&gt;

&lt;span class="n"&gt;durations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;time_to_event&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;event_observed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;df&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;event&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;apply&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;fail&amp;#39;&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;fig&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;axes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subplots&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;figsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;axes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;axes&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reshape&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;WeibullFitter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;LogNormalFitter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;LogLogisticFitter&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;ExponentialFitter&lt;/span&gt;&lt;span class="p"&gt;()]):&lt;/span&gt;
    &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;durations&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;event_observed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;qq_plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;axes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


![qq_plot](https://i.imgur.com/9Iq471K.png)

### LogNormal


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lnf = LogNormalFitter().fit(durations, event_observed)
lnf.summary
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/63svVIc.png)


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plt.figure(figsize=(10, 24))
plt.subplot(4, 1, 1)
lnf.plot_survival_function()
plt.title(&amp;#39;Survival Curve&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Survival Probability&amp;#39;)

plt.subplot(4, 1, 2)
lnf.plot_cumulative_density()
plt.title(&amp;#39;Cumulative Failure Density&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Cum. Density Prob. (failure)&amp;#39;)


plt.subplot(4, 1, 3)
lnf.plot_hazard()
plt.title(&amp;#39;Hazard Function&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Hazard Function (pdf)&amp;#39;)

plt.subplot(4, 1, 4)
lnf.plot_cumulative_hazard()
plt.title(&amp;#39;Cumulative Hazard Function&amp;#39;)
plt.xlabel(&amp;#39;Time to Event (days)&amp;#39;)
plt.ylabel(&amp;#39;Cumulative Hazard Function&amp;#39;)

plt.show()
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/yIc1vip.png)

### Poisson 
Having explored hazard function, which shows unpredictable but extremely low failure rate, it is reasonable to assume the part's failure rate will converge to a constant (random failure in bathtub curve). With that constant failure rate - probability of failure in day, I can convert that to **Mean Time Between Failure (MTBF)** and **Annualized Failure Rate (AFR)**.


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# ultimate failure rate
fr = lnf.hazard_.iloc[-1, 0]
MTBF_days = 1/fr
MTBF_mons = round(MTBF_days / 30, 1)
MTBF_yrs = round(MTBF_days / 365, 1)

AFR = fr*365

num_active_parts = 200000
num_active_parts * AFR  # estimated number of failures per year out of 200K active parts
&lt;/pre&gt;&lt;/div&gt;



To fit in a possion distribution, I only need one independent variable. That is average failure rate, and I use AFR multiplied by number of active part base. 



&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;scipy.stats&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;poisson&lt;/span&gt;

&lt;span class="n"&gt;mu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num_active_parts&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;AFR&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;arange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;poisson&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pmf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mu&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;plt&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;Number of failures occur in a year in Prob.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/NLDXu3L.png)

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;plt.plot(x, poisson.cdf(x, mu))
plt.title(&amp;#39;Cumu. Demand Distribution (Probability of number of failures less than x)&amp;#39;)
plt.xlabel(&amp;#39;x (demand)&amp;#39;)
plt.show()
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/1BuH6tk.png)




&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;i = np.arange(0.01, 1, 0.01)
plt.plot(i, poisson.isf(1-i, mu)) # cdf modified from isf, for some reason, there is no inverse CDF, but inverse survival function
plt.title(&amp;#39;Inverse CDF&amp;#39;)
plt.show()
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/ooJdvsh.png)


With the cummulative density distribution, I can use its inverse function to map cummulative failure rate back to number of parts that failures migth happen - which is equivalent to the number of spares we would like prepare when a failure happens. 


## (Bonus) Spares Demand Forecast using Newsvendor Model

### Newsvendor Model
The optimal spare quantiy given underage cost $C_u$ and overage cost $C_o$ is to minimize expected overall cost:
To minize:
$$
Expected\ Overage\ Cost + Expected\ Underage\ Cost\ \\
= E(Demand&lt;Q)\times C_o + E(Demand&gt;Q) \times C_u \\
$$

Equals to derivative = 0, equals to
$$
P(Demand&lt;Q*) = {C_u\over C_u+C_o} \\
==Q* = F^{-1}({C_u \over C_u+C_o})
$$

## Results

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SLAs = [0.50, 0.75, 0.95, 0.96, 0.97, 0.98, 0.99, 0.9999999, 1]
print(&amp;#39;{:&amp;lt;30}{:&amp;lt;40}&amp;#39;.format(&amp;#39;Reliability&amp;#39;, &amp;#39;# Spares&amp;#39;))
for sla in SLAs:
    print(&amp;#39;{:&amp;lt;30}{:&amp;lt;40}&amp;#39;.format(sla, poisson.isf(1-sla, mu)))
&lt;/pre&gt;&lt;/div&gt;


![](https://i.imgur.com/ypUvju4.png)

This simplified model (constant failure rate = 0.0003 per day / AFR = 203 per year) fitted in poisson distribution recommends 237 spares in a year to achieve 99% reliability or when ${C_u\over C_u+C_o} = 0.99$.


## Reference
* https://www.youtube.com/watch?v=XHYFNraQEEo
* https://towardsdatascience.com/survival-analysis-intuition-implementation-in-python-504fde4fcf8e
* https://lifelines.readthedocs.io/en/latest/Quickstart.html

&lt;/details&gt;</content><category term="Project"></category><category term="python"></category></entry></feed>